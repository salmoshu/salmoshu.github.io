import{_ as n,c as i,j as a,a as s,G as r,w as e,a0 as l,B as p,o as d}from"./chunks/framework.CMtr6uOw.js";const C=JSON.parse('{"title":"附录F. 配置文件","description":"","frontmatter":{"sidebarDepth":3},"headers":[],"relativePath":"algorithm/RTKLIB手册/10-appendixF.md","filePath":"algorithm/RTKLIB手册/10-appendixF.md"}'),h={name:"algorithm/RTKLIB手册/10-appendixF.md"},m={id:"pos1-posmode-static-kinematic-static-start-movingbase-fixed",tabindex:"-1"},f={id:"pos2-varholdamb-0-1-1-0-meters",tabindex:"-1"},u={id:"pos2-gloarmode-on-fix-and-hold-autocal",tabindex:"-1"},b={id:"pos2-gainholdamb-0-01",tabindex:"-1"},x={id:"pos2-arthresmin-pos2-arthresmax-1-5-10",tabindex:"-1"},k={id:"pos2-arfilter-on",tabindex:"-1"},F={id:"pos2-arthres1-0-004-0-10",tabindex:"-1"},P={id:"pos2-arthres2",tabindex:"-1"},v={id:"pos2-arthres3-1e-9-1e-7",tabindex:"-1"},q={id:"pos2-arthres4-0-00001-0-001",tabindex:"-1"},S={id:"pos2-minfixsats-4",tabindex:"-1"},g={id:"pos2-minholdsats-5",tabindex:"-1"},L={id:"pos2-mindropsats-10",tabindex:"-1"},B={id:"pos2-rcvstds-on-off",tabindex:"-1"},T={id:"pos2-rejionno-1-0-2-0",tabindex:"-1"};function R(y,o,N,I,G,A){const t=p("font");return d(),i("div",null,[o[51]||(o[51]=a("h1",{id:"附录f-配置文件",tabindex:"-1"},[s("附录F. 配置文件 "),a("a",{class:"header-anchor",href:"#附录f-配置文件","aria-label":'Permalink to "附录F. 配置文件"'},"​")],-1)),o[52]||(o[52]=a("p",null,"该章节不会对所有配置选项都做解释，而是针对其中可能有用的一些选项进行分析与解释。这里按照配置文件中的配置参数呈现的顺序进行描述（而非它们在 RTKNAVI/RTKPOST 菜单中显示的顺序），不过这些参数对于两者都是适用的。与第3章中提到的配置描述相比，这里的会更详细，并且包含一些调试经验。",-1)),o[53]||(o[53]=a("p",null,"后文中的参数值是用于 5 Hz 的流动站（rover）研究的配置参数。同样的配置文件可用于 RTKNAVI、RTKRCV、RTKPOST 或 RNX2RTKP。",-1)),a("p",null,[o[1]||(o[1]=s("下面以")),r(t,{color:"#007BFF"},{default:e(()=>o[0]||(o[0]=[s("蓝色")])),_:1}),o[2]||(o[2]=s("高亮显示的设置和选项仅适用于 demo5 代码，而不适用于 RTKLIB 原始版本。但除此之外，下面描述的大部分内容适用于这两种代码。demo5 作者是基于 Ublox M8T 和 F9P 接收机进行 GNSS-RTK 研究的，并且主要应用于短基线环境，因此这些设置更适用于这些低成本接收机。"))]),o[54]||(o[54]=a("h2",{id:"setting1",tabindex:"-1"},[s("SETTING1 "),a("a",{class:"header-anchor",href:"#setting1","aria-label":'Permalink to "SETTING1"'},"​")],-1)),a("h3",m,[o[4]||(o[4]=s("pos1-posmode = static, kinematic, ")),r(t,{color:"#007BFF"},{default:e(()=>o[3]||(o[3]=[s("static-start")])),_:1}),o[5]||(o[5]=s(", movingbase, fixed ")),o[6]||(o[6]=a("a",{class:"header-anchor",href:"#pos1-posmode-static-kinematic-static-start-movingbase-fixed","aria-label":'Permalink to "pos1-posmode = static, kinematic, <font color="#007BFF">static-start</font>, movingbase, fixed"'},"​",-1))]),o[55]||(o[55]=l(`<ul><li>static：如果 rover 是静止的，使用“static”；</li><li>kinematic：如果它是移动的，使用“kinematic”（或“static-start”）；</li><li>static-start：“static-start”假设 rover 在第一次 Fix 完成之前是静止的，然后切换到动态模式，程序允许滤波器利用 rover 最开始是静止的先验信息；</li><li>movingbase：如果 base 和 rover 都在移动，那么可以使用“movingbase”模式（通常用来定姿）。“movingbase”模式与 dynamics 模式不兼容，请不要同时启用两者。如果 base 与 rover 保持固定距离，在 movingbase 模式下设置“pos2-baselen”和“pos2-basesig”；</li><li>fixed：如果你知道 rover 的确切位置，并且只对分析残差感兴趣，可以使用“fixed”。</li></ul><h3 id="pos1-frequency-l1-l1-l2-l1-l2-l5" tabindex="-1">pos1-frequency = L1, L1+L2, L1+L2+L5 <a class="header-anchor" href="#pos1-frequency-l1-l1-l2-l1-l2-l5" aria-label="Permalink to &quot;pos1-frequency = L1, L1+L2, L1+L2+L5&quot;">​</a></h3><ul><li>L1：单频接收机使用“L1”；</li><li>L1+L2/E5b：若 rover 使用 L2 GPS/GLONASS/Beidou and/or Galileo E5b，则用“L1+L2/E5b”；</li><li>L1+L2+L5：“L1+L2+L5”则表示 rover 还会使用 L5 GPS/GLONASS/Bediou and/or Galileo E5a 数据</li></ul><p>注意这其中不包含 L1+L5 的单独形式，另外 RTKLIB 对 Beidou 的 B2a 频点还没有很好的支持（demo5 b34h版本开始支持B2a了）。</p><h3 id="pos1-soltype-forward-backward-combined" tabindex="-1">pos1-soltype = forward, backward, combined <a class="header-anchor" href="#pos1-soltype-forward-backward-combined" aria-label="Permalink to &quot;pos1-soltype = forward, backward, combined&quot;">​</a></h3><p>滤波类型表示卡尔曼滤波在后处理中运行的时间方向。“combined”模式首先向前运行过滤器，然后向后运行并组合结果。对于每个历元：</p><ul><li>如果两个方向都有Fix，那么组合的结果是两个Fix状态的平均值，除非两者之间的差异太大，在这种情况下状态将是float的。</li><li>如果只有一个方向有Fix，则使用该值固定状态。</li><li>如果两个方向都是float的，那么平均值将被使用，状态将是float的。</li></ul><p>使用“combined”后的结果并不总是更好，因为在任何一个方向上运行时错误的Fix通常会导致合并后的结果是float或异常解。“combined”的主要优点是，它通常会为您提供数据开头的固定状态，而仅向前的解决方案需要一些时间来收敛。</p><p>在“combined”模式下，偏差状态在开始向后运行之前被重置，以最大限度地提高向前和向后解的独立性。在“combined mode-no phase reset”中，不重置偏置状态可以避免在反向解开始时需要重新收敛。只有在调试时遇到初始定位困难，想要了解正确的卫星相位偏差时，才使用“backward”设置。</p><h3 id="pos1-elmask-15-degrees" tabindex="-1">pos1-elmask = 15 (degrees) <a class="header-anchor" href="#pos1-elmask-15-degrees" aria-label="Permalink to &quot;pos1-elmask = 15 (degrees)&quot;">​</a></h3><p>用于计算位置的最小卫星高度，通常将其设置为 10-15 度，以减少多径效应进入解算的概率，但这个设置取决于 rover 的环境。天空视野越开阔，这个值可以设置得越低。低仰角卫星还会带来较大的大气误差，这也是排除最低仰角卫星的另一个原因。</p><p>对于城市峡谷环境，最好将仰角设高。另外在往下的角度范围内，固定率与仰角的设置并不具备可参考的规律。</p><h3 id="pos1-snrmask-r-pos1-snrmask-b-off-on" tabindex="-1">pos1-snrmask-r, pos1-snrmask-b = off,on <a class="header-anchor" href="#pos1-snrmask-r-pos1-snrmask-b-off-on" aria-label="Permalink to &quot;pos1-snrmask-r, pos1-snrmask-b = off,on&quot;">​</a></h3><p>用于计算位置的 rover（-r）和 base（-b）的最小卫星信噪比（SNR）。最优值会因接收机类型和天线类型而异，不过在处理较具挑战性的数据集时，最好启用它以移除低质量卫星，从而改善结果。</p><h3 id="pos1-snrmask-l1-35-35-35-35-35-35-35-35-35" tabindex="-1">pos1-snrmask_L1 =35,35,35,35,35,35,35,35,35 <a class="header-anchor" href="#pos1-snrmask-l1-35-35-35-35-35-35-35-35-35" aria-label="Permalink to &quot;pos1-snrmask_L1 =35,35,35,35,35,35,35,35,35&quot;">​</a></h3><p>为每 5 度仰角设置信噪比（SNR）阈值。可以将所有值设为相同，根据标称信噪比选择30到38分贝之间的某个值。这些值仅在“pos1-snrmask_x”设置为“on”时使用。如果使用双频，你还需要设置“pos1-snrmask_L2”和/或“pos1-snrmask_L5”。</p><h3 id="pos1-dynamics-on" tabindex="-1">pos1-dynamics = on <a class="header-anchor" href="#pos1-dynamics-on" aria-label="Permalink to &quot;pos1-dynamics = on&quot;">​</a></h3><p>将 rover 设置为 dynamic 会在滤波器中为 rover 添加速度和加速度状态。这将改善“kinematic”和“静static-start”模式的结果，但对“static”模式没有影响。确保根据 rover 的加速度特性适当设置“prnaccelh”和“prnaccelv”。dynamic 与“movingbase”模式不兼容，因此在使用该模式时需将其关闭。</p><h3 id="pos1-posopt1-off-on-sat-pcv" tabindex="-1">pos1-posopt1 = off, on (Sat PCV) <a class="header-anchor" href="#pos1-posopt1-off-on-sat-pcv" aria-label="Permalink to &quot;pos1-posopt1 = off, on (Sat PCV)&quot;">​</a></h3><p>设置是否使用卫星天线相位中心变化。对于RTK（实时动态定位），建议关闭此选项，因为天线偏移会相互抵消。对于PPP（精密单点定位），建议启用，但如果设置为“on”，请确保在文件参数中指定卫星天线PCV（相位中心变化）文件。</p><h3 id="pos1-posopt2-off-on-rec-pcv" tabindex="-1">pos1-posopt2 = off, on (Rec PCV) <a class="header-anchor" href="#pos1-posopt2-off-on-rec-pcv" aria-label="Permalink to &quot;pos1-posopt2 = off, on (Rec PCV)&quot;">​</a></h3><p>设置是否使用接收机天线相位中心变化。如果设置为“on”，你需要在文件参数中指定接收机天线PCV（相位中心变化）文件，并在天线部分指定 base 和 rover 使用的接收机天线类型。只有测量级天线才包含在IGS提供的天线文件中，因此仅当你的天线在该文件中时才使用此选项。它主要影响z轴的精度，因此如果你关注高程，这可能很重要。如果 base 和 rover 的天线相同，可以关闭此选项，因为它们会相互抵消。</p><h3 id="pos1-posopt5-off-on-raim-fde" tabindex="-1">pos1-posopt5 = off, on (RAIM FDE) <a class="header-anchor" href="#pos1-posopt5-off-on-raim-fde" aria-label="Permalink to &quot;pos1-posopt5 = off, on (RAIM FDE)&quot;">​</a></h3><p>如果某颗卫星的残差超过阈值，该卫星将被排除。这只会排除误差非常大的卫星，但需要相当多的计算量，因此通常将其禁用。</p><h3 id="pos1-exclsats" tabindex="-1">pos1-exclsats= <a class="header-anchor" href="#pos1-exclsats" aria-label="Permalink to &quot;pos1-exclsats=&quot;">​</a></h3><p>如果你知道某颗卫星有问题，可以通过在此列出将其从解算中排除。我仅在极少数情况下用于调试，当我怀疑某颗卫星有问题时才会使用。你还可以通过在卫星编号前加“+”来强制使用一颗不健康的卫星。</p><p>剔除示例：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 使用空格分隔字符串</span></span>
<span class="line"><span>pos1-exclsats = G01 G02 R03</span></span></code></pre></div><h3 id="pos1-navsys-7-15" tabindex="-1">pos1-navsys = 7, 15, <a class="header-anchor" href="#pos1-navsys-7-15" aria-label="Permalink to &quot;pos1-navsys = 7, 15,&quot;">​</a></h3><p>尽量启用所有可用的卫星系统，因为更多观测信息通常更好。例外情况是，如果使用EGNOS卫星，则不应启用SBAS（卫星增强系统）。</p><h2 id="setting2" tabindex="-1">SETTING2 <a class="header-anchor" href="#setting2" aria-label="Permalink to &quot;SETTING2&quot;">​</a></h2><h3 id="pos2-armode-continuous-fix-and-hold" tabindex="-1">pos2-armode = continuous, fix-and-hold <a class="header-anchor" href="#pos2-armode-continuous-fix-and-hold" aria-label="Permalink to &quot;pos2-armode = continuous, fix-and-hold&quot;">​</a></h3><p>模糊度固定策略。“continuous”模式不利用修正来调整相位偏置状态，因此它最不受错误修正的影响。“fix-and-hold”确实使用来自Fix的反馈来帮助跟踪模糊性。我更喜欢对动态rover使用“fix-and-hold”，并将跟踪增益(pos2-varholdamb)调整到足够低的水平，以尽量减少错误固定的机会。如果“armode”没有设置为“fixe-and-hold”，那么下面任何指向hold的选项都不适用。</p>`,33)),a("h3",f,[r(t,{color:"#007BFF"},{default:e(()=>o[7]||(o[7]=[s("pos2-varholdamb=0.1, 1.0 (meters)")])),_:1}),o[8]||(o[8]=s()),o[9]||(o[9]=a("a",{class:"header-anchor",href:"#pos2-varholdamb-0-1-1-0-meters","aria-label":'Permalink to "<font color="#007BFF">pos2-varholdamb=0.1, 1.0 (meters)</font>"'},"​",-1))]),o[56]||(o[56]=a("p",null,"在demo5代码中，可以使用该参数调整fix-and-hold的跟踪增益。它实际上是一个方差而不是增益，所以较大的值会产生较低的增益。0.1是默认值，超过100的值影响很小。这个值被用作在hold期间产生的伪测量的方差，它提供反馈来驱动卡尔曼滤波器中的偏置状态。我发现从0.1到1.0的值提供了足够的增益来帮助跟踪，同时在大多数情况下仍然避免跟踪错误的Fix。",-1)),a("h3",u,[o[11]||(o[11]=s("pos2-gloarmode = on, ")),r(t,{color:"#007BFF"},{default:e(()=>o[10]||(o[10]=[s("fix-and-hold, autocal")])),_:1}),o[12]||(o[12]=s()),o[13]||(o[13]=a("a",{class:"header-anchor",href:"#pos2-gloarmode-on-fix-and-hold-autocal","aria-label":'Permalink to "pos2-gloarmode = on, <font color="#007BFF">fix-and-hold, autocal</font>"'},"​",-1))]),o[57]||(o[57]=a("p",null,[s("GLONASS卫星的整型模糊度解析。如果你的接收器类型相同，或者两者都没有Glonass硬件偏差，你可以将其设置为“on”。如果你的接收器偏差不同，你需要考虑信道间偏差。最简单的方法是将该参数设置为“fix-and-hold”，在这种情况下，GLONASS卫星将不会用于模糊度的固定，直到第一次hold后开始校准信道间偏差之后。或者，您可以将此参数设置为“autocal”，然后使用“pos2-arthres2”参数指定基地和rover之间的差异硬件偏移量。这将使GLONASS卫星能够立即用于固定模糊度，因此通常比“fix-and-hold”设置的性能更好。“autocal”特性还可用于使用迭代方法确定具有零基线或短基线的通道间偏差。 延伸博客："),a("a",{href:"https://blog.csdn.net/weixin_42918498/article/details/119118410",target:"_blank",rel:"noreferrer"},"https://blog.csdn.net/weixin_42918498/article/details/119118410")],-1)),a("h3",b,[r(t,{color:"#007BFF"},{default:e(()=>o[14]||(o[14]=[s("pos2-gainholdamb=0.01")])),_:1}),o[15]||(o[15]=s()),o[16]||(o[16]=a("a",{class:"header-anchor",href:"#pos2-gainholdamb-0-01","aria-label":'Permalink to "<font color="#007BFF">pos2-gainholdamb=0.01</font>"'},"​",-1))]),o[58]||(o[58]=a("p",null,"在demo5代码中，GLONASS卫星的信道间偏置校准增益可以通过该参数进行调整。",-1)),o[59]||(o[59]=a("h3",{id:"pos2-arthres-3",tabindex:"-1"},[s("pos2-arthres = 3 "),a("a",{class:"header-anchor",href:"#pos2-arthres-3","aria-label":'Permalink to "pos2-arthres = 3"'},"​")],-1)),o[60]||(o[60]=a("p",null,"这是用于确定模糊度解决方案是否有足够的置信度来声明Fix的阈值。它是次优解与最优解的残差的平方之比。我通常将比率保留为默认值3.0，并调整所有其他参数以适应这个值。虽然较大的应收账款比率比较低的应收账款比率表明更高的置信度，但两者之间并没有固定的关系。卡尔曼滤波状态的误差越大，对于给定的AR比，该解的置信度就越低。一般来说，卡尔曼滤波器的误差在它第一次收敛时是最大的，所以这是最有可能得到错误修正的时间。减少pos2-arthers有助于避免这种情况。",-1)),a("h3",x,[r(t,{color:"#007BFF"},{default:e(()=>o[17]||(o[17]=[s("pos2-arthresmin, pos2-arthresmax=1.5, 10")])),_:1}),o[18]||(o[18]=s()),o[19]||(o[19]=a("a",{class:"header-anchor",href:"#pos2-arthresmin-pos2-arthresmax-1-5-10","aria-label":'Permalink to "<font color="#007BFF">pos2-arthresmin, pos2-arthresmax=1.5, 10</font>"'},"​",-1))]),o[61]||(o[61]=a("p",null,"如果这些值被设置为等于pos2-arthres，那么模糊度分辨率阈值将被固定。否则，阈值将根据模糊度分辨率中使用的卫星数量进行调整。标称值用于8对卫星，随卫星数量的增加而减小，随卫星数量的减少而增大。调整后的值被最小和最大阈值限制截断。调整率以FFRT方法使用的调整率为基础，但只根据卫星数量而不根据模式强度进行调整。",-1)),a("h3",k,[r(t,{color:"#007BFF"},{default:e(()=>o[20]||(o[20]=[s("pos2-arfilter = on")])),_:1}),o[21]||(o[21]=s()),o[22]||(o[22]=a("a",{class:"header-anchor",href:"#pos2-arfilter-on","aria-label":'Permalink to "<font color="#007BFF">pos2-arfilter = on</font>"'},"​",-1))]),o[62]||(o[62]=a("p",null,"将此设置为on将限定新卫星或从周期滑动中恢复的卫星。如果卫星在第一次添加时显著降低了AR比率，则其用于模糊分辨率的使用将被延迟。打开这个选项可以让你减少“arlocknt”，它有类似的目的，但有一个盲目的延迟计数。",-1)),a("h3",F,[r(t,{color:"#007BFF"},{default:e(()=>o[23]||(o[23]=[s("pos2-arthres1 = 0.004-0.10")])),_:1}),o[24]||(o[24]=s()),o[25]||(o[25]=a("a",{class:"header-anchor",href:"#pos2-arthres1-0-004-0-10","aria-label":'Permalink to "<font color="#007BFF">pos2-arthres1 = 0.004-0.10</font>"'},"​",-1))]),o[63]||(o[63]=a("p",null,"直到位置状态的方差达到这个阈值，整数模糊度解析才会延迟。它的目的是在卡尔曼滤波器中的偏置状态有时间收敛之前避免错误Fix。特别重要的是，如果您将1的值设置为大于100，并且使用单个星座或单个频率解决方案，则将此值设置为相对较低的值。如果您看到零的AR比率扩展到您的解决方案中太远，则可能需要增加该值，因为这意味着由于尚未达到阈值而禁用了模糊度固定。我发现0.004到0.10通常适合我，但如果你的测量质量较低，你可能需要增加这个值，以避免过度延迟第一次Fix或在多次循环滑动发生后丢失Fix。",-1)),a("h3",P,[r(t,{color:"#007BFF"},{default:e(()=>o[26]||(o[26]=[s("pos2-arthres2")])),_:1}),o[27]||(o[27]=s()),o[28]||(o[28]=a("a",{class:"header-anchor",href:"#pos2-arthres2","aria-label":'Permalink to "<font color="#007BFF">pos2-arthres2</font>"'},"​",-1))]),o[64]||(o[64]=a("p",null,"GLONASS的相对硬件偏差(以米为单位)。此参数仅在pos2gloarmode设置为“autocal”时使用，用于指定两个不同接收器制造商之间的信道间偏置。要查找常见接收方类型的适当值，以及如何使用该参数进行迭代搜索以查找未指定的接收方类型的值，请参阅这篇文章。",-1)),a("h3",v,[r(t,{color:"#007BFF"},{default:e(()=>o[29]||(o[29]=[s("pos2-arthres3 = 1e-9,1e-7")])),_:1}),o[30]||(o[30]=s()),o[31]||(o[31]=a("a",{class:"header-anchor",href:"#pos2-arthres3-1e-9-1e-7","aria-label":'Permalink to "<font color="#007BFF">pos2-arthres3 = 1e-9,1e-7</font>"'},"​",-1))]),o[65]||(o[65]=a("p",null,'GLONASS硬件偏置状态的初始方差。此参数仅在pos2-gloarmode设置为" autocal "时使用。较小的值将赋予pos2-arthres2中指定的初始值更大的权重。当pos2-arthres2设置为已知偏差时，我使用1e-9，迭代搜索时使用1e-7。',-1)),a("h3",q,[r(t,{color:"#007BFF"},{default:e(()=>o[32]||(o[32]=[s("pos2-arthres4 = 0.00001,0.001")])),_:1}),o[33]||(o[33]=s()),o[34]||(o[34]=a("a",{class:"header-anchor",href:"#pos2-arthres4-0-00001-0-001","aria-label":'Permalink to "<font color="#007BFF">pos2-arthres4 = 0.00001,0.001</font>"'},"​",-1))]),o[66]||(o[66]=a("p",null,"卡尔曼滤波处理GLONASS硬件偏置状态的噪声。较小的值将赋予pos2-arthres2中指定的初始值更大的权重。当pos2-arthres2设置为已知偏差时，我使用0.00001，对于迭代搜索，我使用0.001。",-1)),o[67]||(o[67]=a("h3",{id:"pos2-arlockcnt-0-5-sample-rate",tabindex:"-1"},[s("pos2-arlockcnt = 0, 5(*sample rate) "),a("a",{class:"header-anchor",href:"#pos2-arlockcnt-0-5-sample-rate","aria-label":'Permalink to "pos2-arlockcnt = 0, 5(*sample rate)"'},"​")],-1)),o[68]||(o[68]=a("p",null,"在将新卫星或从周跳中恢复的卫星用于整数模糊度分辨率之前，延迟它的采样数。避免由于包含一个没有时间收敛的卫星而导致应收账款比率的损坏。与“arfilter”一起使用。请注意，单位是样本，而不是时间单位，所以如果你改变了rover测量采样率，它可能需要调整。对于u-blox接收器，我通常将其设置为0，因为u-blox接收器非常善于标记可疑的观察结果，但对于其他接收器，我将其设置为更高。",-1)),a("h3",S,[r(t,{color:"#007BFF"},{default:e(()=>o[35]||(o[35]=[s("pos2-minfixsats = 4")])),_:1}),o[36]||(o[36]=s()),o[37]||(o[37]=a("a",{class:"header-anchor",href:"#pos2-minfixsats-4","aria-label":'Permalink to "<font color="#007BFF">pos2-minfixsats = 4</font>"'},"​",-1))]),o[69]||(o[69]=a("p",null,"获得Fix所需的最小卫星数。用于避免来自极少数卫星的错误定位，特别是在频繁的周期滑动期间。",-1)),a("h3",g,[r(t,{color:"#007BFF"},{default:e(()=>o[38]||(o[38]=[s("pos2-minholdsats = 5")])),_:1}),o[39]||(o[39]=s()),o[40]||(o[40]=a("a",{class:"header-anchor",href:"#pos2-minholdsats-5","aria-label":'Permalink to "<font color="#007BFF">pos2-minholdsats = 5</font>"'},"​",-1))]),o[70]||(o[70]=a("p",null,"保存整数模糊度结果所需的最小值。用于避免极少数卫星的错误hold，特别是在频繁的周期滑动期间。",-1)),a("h3",L,[r(t,{color:"#007BFF"},{default:e(()=>o[41]||(o[41]=[s("pos2-mindropsats = 10")])),_:1}),o[42]||(o[42]=s()),o[43]||(o[43]=a("a",{class:"header-anchor",href:"#pos2-mindropsats-10","aria-label":'Permalink to "<font color="#007BFF">pos2-mindropsats = 10</font>"'},"​",-1))]),o[71]||(o[71]=a("p",null,"每历元排除一颗卫星的最小卫星数。在每个历元中都排除了不同的卫星。如果排除该卫星导致AR比率显著改善，则将该卫星从用于AR的卫星列表中删除。",-1)),a("h3",B,[r(t,{color:"#007BFF"},{default:e(()=>o[44]||(o[44]=[s("pos2-rcvstds = on,off")])),_:1}),o[45]||(o[45]=s()),o[46]||(o[46]=a("a",{class:"header-anchor",href:"#pos2-rcvstds-on-off","aria-label":'Permalink to "<font color="#007BFF">pos2-rcvstds = on,off</font>"'},"​",-1))]),o[72]||(o[72]=l('<p>实验功能。启用此功能可使原始伪距和相位测量观测值的测量方差根据接收器报告的测量值的标准偏差进行调整。此功能目前仅支持u-blox接收器。方差调整是在根据stats-errphaseel参数对卫星高程进行调整的基础上进行的。 我通常把这个关掉会得到更好的结果。</p><h3 id="pos2-arelmask-15" tabindex="-1">pos2-arelmask = 15 <a class="header-anchor" href="#pos2-arelmask-15" aria-label="Permalink to &quot;pos2-arelmask = 15&quot;">​</a></h3><p>在功能上与默认值零没有区别，因为海拔小于“elmask”不会用于模糊度固定，但我更改了它以避免混淆。</p><h3 id="pos2-arminfix-20-100-5-20-sample-rate" tabindex="-1">pos2-arminfix = 20-100 (5-20*sample rate) <a class="header-anchor" href="#pos2-arminfix-20-100-5-20-sample-rate" aria-label="Permalink to &quot;pos2-arminfix = 20-100 (5-20*sample rate)&quot;">​</a></h3><p>模糊度hold所需的连续fix样本数。增加这个值可能是减少错误hold的最有效的方法，但也会增加第一次hold和重新获得hold的时间。随着模糊度跟踪增益的减小(即pos2-varholdamb的增加)和观测次数的增加，可以减小误差。请注意，如果rover测量采样率发生变化，则可能需要调整此值。</p><h3 id="pos2-elmaskhold-15" tabindex="-1">pos2-elmaskhold = 15 <a class="header-anchor" href="#pos2-elmaskhold-15" aria-label="Permalink to &quot;pos2-elmaskhold = 15&quot;">​</a></h3><p>在功能上与默认值零没有什么不同，因为海拔小于“elmask”不会用于保存模糊度固定结果，但我更改了它以避免混淆。</p><h3 id="pos2-aroutcnt-100-20-sample-rate" tabindex="-1">pos2-aroutcnt = 100 (20*sample rate) <a class="header-anchor" href="#pos2-aroutcnt-100-20-sample-rate" aria-label="Permalink to &quot;pos2-aroutcnt = 100 (20*sample rate)&quot;">​</a></h3><p>导致模糊度被重置的连续缺失样本数。同样，如果rover测量采样率发生变化，则需要调整该值。</p><h3 id="pos2-maxage-100" tabindex="-1">pos2-maxage = 100 <a class="header-anchor" href="#pos2-maxage-100" aria-label="Permalink to &quot;pos2-maxage = 100&quot;">​</a></h3><p>rover测量和base测量之间的最大延迟(差分龄期)，以秒为单位。这通常是由于行为不正常的无线链路缺少测量而发生的。我已经将其从默认值增加，因为我发现即使这个值变得相当大，假设在第一次固定并保持之后出现了退出，我仍然经常得到很好的结果。</p>',11)),a("h3",T,[o[48]||(o[48]=s("pos2-rejionno = ")),r(t,{color:"#007BFF"},{default:e(()=>o[47]||(o[47]=[s("1.0-2.0")])),_:1}),o[49]||(o[49]=s()),o[50]||(o[50]=a("a",{class:"header-anchor",href:"#pos2-rejionno-1-0-2-0","aria-label":'Permalink to "pos2-rejionno = <font color="#007BFF">1.0-2.0</font>"'},"​",-1))]),o[73]||(o[73]=l('<p>如果卡尔曼滤波残差大于这个以米为单位的值，则拒绝测量。在demo5b33代码之前，该值在没有对代码和相位测量进行调整的情况下应用。在较新的版本中，该值仍然在不调整相位测量的情况下应用，但要乘以代码测量的比值。这允许将其设置为适合相位测量的值。我通常将其设置为1.0，这对于捕获和拒绝未标记的周期滑动非常有帮助，但偶尔发现我需要将其设置得更高。将它设置得太低会导致卡尔曼滤波器在低质量数据中发散，所以我将默认值设置为2.0，尽管我通常使用1.0。</p><h2 id="output" tabindex="-1">OUTPUT <a class="header-anchor" href="#output" aria-label="Permalink to &quot;OUTPUT&quot;">​</a></h2><h3 id="out-solformat-enu-llh-xyz" tabindex="-1">out-solformat = enu, llh, xyz <a class="header-anchor" href="#out-solformat-enu-llh-xyz" aria-label="Permalink to &quot;out-solformat = enu, llh, xyz&quot;">​</a></h3><p>我通常对探测器和基地之间的相对距离感兴趣，所以将其设置为“enu”。如果您对绝对位置感兴趣，请将其设置为“llh”，但请确保在“ant2”设置中设置了确切的基本位置。如果需要精确的z轴测量，请小心使用此设置。只有llh格式会给你一个恒定的z高度，如果rover在恒定的高度。“Enu”和“xyz”是笛卡尔坐标，所以z轴遵循一个平面，而不是地球的曲率。如果基站离探测器较远，这可能会导致特别大的误差，因为曲率会随着距离的增加而增加。</p><h3 id="out-outhead-on" tabindex="-1">out-outhead = on <a class="header-anchor" href="#out-outhead-on" aria-label="Permalink to &quot;out-outhead = on&quot;">​</a></h3><p>解决方案没有功能差异，只是将更多信息输出到结果文件。</p><h3 id="out-outopt-on" tabindex="-1">out-outopt = on <a class="header-anchor" href="#out-outopt-on" aria-label="Permalink to &quot;out-outopt = on&quot;">​</a></h3><p>解决方案没有功能差异，只是将更多信息输出到结果文件。</p><h3 id="out-outstat-residual" tabindex="-1">out-outstat = residual <a class="header-anchor" href="#out-outstat-residual" aria-label="Permalink to &quot;out-outstat = residual&quot;">​</a></h3><p>解决方案没有功能差异，只是将残余输出到文件中。残差对于调试解决方案中的问题非常有用，只要残差文件与解决方案文件位于同一文件夹中，就可以使用RTKPLOT绘制残差文件。</p><h2 id="statistics" tabindex="-1">STATISTICS <a class="header-anchor" href="#statistics" aria-label="Permalink to &quot;STATISTICS&quot;">​</a></h2><h3 id="stats-eratio1-300-stats-eratio2-300-stats-eratio5-300" tabindex="-1">stats-eratio1 = 300 /stats-eratio2 = 300 /stats-eratio5 = 300 <a class="header-anchor" href="#stats-eratio1-300-stats-eratio2-300-stats-eratio5-300" aria-label="Permalink to &quot;stats-eratio1 = 300 /stats-eratio2 = 300 /stats-eratio5 = 300&quot;">​</a></h3><p>伪距测量值与载波相位测量值的标准差之比。我发现更大的值更适合低成本的接收器，但默认值100通常更适合更昂贵的接收器，因为它们的伪距测量噪声更小。较大的值往往会使卡尔曼滤波器收敛得更快，导致更快的首次Fix，但它也增加了错误Fix的机会。如果增加这个值，则应该将pos2-arthres1设置得足够低，以防止在卡尔曼滤波器有时间收敛之前找到Fix。我相信增加这个值与增加伪间隔平滑算法上的时间常数具有类似的效果，因为它滤除了伪间隔测量中更多的较高频率，同时保持了低频成分。</p><h3 id="stats-prnaccelh-3-0" tabindex="-1">stats-prnaccelh = 3.0 <a class="header-anchor" href="#stats-prnaccelh-3-0" aria-label="Permalink to &quot;stats-prnaccelh = 3.0&quot;">​</a></h3><p>如果启用了接收器动态，则使用此值设置rover接收器加速度在水平组件中的标准偏差。这个值应该包括所有频率的加速度，而不仅仅是低频。它应该描述探测器天线的任何运动，而不仅仅是整个探测器的运动，所以它可能比你想象的要大。它将包括振动、路面颠簸等产生的加速度，以及整个Rover更明显的刚体加速度。可以通过运行将该值设置为较大值的解决方案，然后使用RTKPLOT检查解决方案文件中的加速值来估计它。</p><h3 id="stats-prnaccelv-1-0" tabindex="-1">stats-prnaccelv = 1.0 <a class="header-anchor" href="#stats-prnaccelv-1-0" aria-label="Permalink to &quot;stats-prnaccelv = 1.0&quot;">​</a></h3><p>关于水平加速度的评论更适用于垂直加速度分量，因为在许多应用中，有意加速度都在水平分量中。最好从实际的GPS测量数据中得出这个值，而不是从刚体Rover的期望中得出这个值。高估这些价值比低估它们要好。</p><h2 id="positions" tabindex="-1">POSITIONS <a class="header-anchor" href="#positions" aria-label="Permalink to &quot;POSITIONS&quot;">​</a></h2><h3 id="ant2-postype-rinexhead-llh-single" tabindex="-1">ant2-postype = rinexhead, llh, single <a class="header-anchor" href="#ant2-postype-rinexhead-llh-single" aria-label="Permalink to &quot;ant2-postype = rinexhead, llh, single&quot;">​</a></h3><p>这是基站天线的位置。如果你只对基地和rover之间的相对距离感兴趣，这个值不需要特别精确。对于后处理，我通常使用RINEX文件头中的大致基站位置。虽然标记为近似，如果您正在使用来自CORS参考站的rinex文件，它通常是精确的。否则，如果我想要绝对位置，我首先根据附近的参考站处理基站数据以获得确切位置，然后使用“llh”或“xyz”选项指定该位置。对于不知道确切基站位置的实时处理，我使用“单一”选项，它使用数据中的单一解决方案来获得基站位置的粗略估计。</p><h3 id="ant2-maxaveep-1" tabindex="-1">ant2-maxaveep = 1 <a class="header-anchor" href="#ant2-maxaveep-1" aria-label="Permalink to &quot;ant2-maxaveep = 1&quot;">​</a></h3><p>当“postype”设置为“single”时，指定用于确定基站位置的平均样本数。</p><p>我将其设置为1，以防止在卡尔曼滤波器开始收敛后基站位置发生变化，因为这似乎会导致较长时间的首次Fix。在大多数情况下，对于后处理，基站位置将来自RINEX文件头，因此您不会使用此设置。但是，如果您正在使用RTCM文件，您甚至可能需要进行后处理。</p><h2 id="misc" tabindex="-1">MISC <a class="header-anchor" href="#misc" aria-label="Permalink to &quot;MISC&quot;">​</a></h2><h3 id="misc-timeinterp-off-on" tabindex="-1">misc-timeinterp =off,on <a class="header-anchor" href="#misc-timeinterp-off-on" aria-label="Permalink to &quot;misc-timeinterp =off,on&quot;">​</a></h3><p>插入基站观测值。如果基站观测样本时间大于5秒，我通常将其设置为“开”。</p>',26))])}const E=n(h,[["render",R]]);export{C as __pageData,E as default};
