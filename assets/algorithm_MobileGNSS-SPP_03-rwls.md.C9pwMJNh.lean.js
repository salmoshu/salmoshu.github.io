import{_ as i,c as a,a0 as h,o as k}from"./chunks/framework.CMtr6uOw.js";const g=JSON.parse('{"title":"3. RWLS","description":"","frontmatter":{"sidebarDepth":2},"headers":[],"relativePath":"algorithm/MobileGNSS-SPP/03-rwls.md","filePath":"algorithm/MobileGNSS-SPP/03-rwls.md"}'),n={name:"algorithm/MobileGNSS-SPP/03-rwls.md"};function t(p,s,l,e,r,E){return k(),a("div",null,s[0]||(s[0]=[h(`<h1 id="_3-rwls" tabindex="-1">3. RWLS <a class="header-anchor" href="#_3-rwls" aria-label="Permalink to &quot;3. RWLS&quot;">​</a></h1><p>由于最小二乘较为简单，能比较方便和快速地对一些方法进行验证，因此初始时我将利用最小二乘进行一些基础的优化。</p><h2 id="_3-1-加权模型" tabindex="-1">3.1 加权模型 <a class="header-anchor" href="#_3-1-加权模型" aria-label="Permalink to &quot;3.1 加权模型&quot;">​</a></h2><h3 id="_3-1-1-rtklib中的bug" tabindex="-1">3.1.1 RTKLIB中的BUG <a class="header-anchor" href="#_3-1-1-rtklib中的bug" aria-label="Permalink to &quot;3.1.1 RTKLIB中的BUG&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-170931.jpg" alt=""></p><p>demo5-b34k版本的RTKLIB在打开SNR加权后轨迹会崩溃，不过这并不是因为SNR加权效果不如等权，这里显然是错误，而非误差。</p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171041.jpg" alt=""></p><p>将ssat[i]改成ssat[sat-1]即可解决，打开SNR加权将提升定位性能。</p><h3 id="_3-1-2-仰角与snr加权" tabindex="-1">3.1.2 仰角与SNR加权 <a class="header-anchor" href="#_3-1-2-仰角与snr加权" aria-label="Permalink to &quot;3.1.2 仰角与SNR加权&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171252.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171332.jpg" alt=""></p><p>以上为使用SNR加权模型WLS在不同场景上的表现，目前由于代码中没有抗差，因此最大漂移指标都比较大。</p><p>基于卫星仰角的GNSS观测模型更适用于专用接收机。然而，对于智能手机，基于信号强度（载噪比，C/N0）的模型比依赖仰角的模型更能有效地处理观测权重[4,5,6]。因为智能手机观测误差往往由信号质量问题主导，而非大气误差，而使用仰角加权观测的动机正是为了解决大气误差</p><h2 id="_3-2-速度估计中的加权" tabindex="-1">3.2 速度估计中的加权 <a class="header-anchor" href="#_3-2-速度估计中的加权" aria-label="Permalink to &quot;3.2 速度估计中的加权&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171434.jpg" alt=""></p><p>RTKLIB中的速度估计原本几乎没有进行加权，其表现的性能如图3-4所示，基本和等权差不多。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CLIGHT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freq;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[nv] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SQR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sig);</span></span></code></pre></div><p>原本加权方法的代码如上所示，其中的<code>err</code>由<code>stats-errdoppler</code>参数来控制。我在<code>resdop</code>中增加了新的加权方法，这里可以直接将伪距中的加权方法拷贝过来，并将原本的加权代码注释掉。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// resdop内部</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prcopt_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opt_ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opt_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opt, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prcopt_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">opt_.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">eratio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // doppler/phase error ratio</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ssat)</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[nv]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">varerr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opt_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ssat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i].sat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i],</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">azel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],sys);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[nv]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">varerr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opt_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i],</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">azel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],sys);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 权的调节（修改H和v）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nv;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j]);</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sig;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">H</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sig;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>具体的，需要在resdop中增加var计算的代码，随后在resdop调用的地方进行加权操作。其中的<code>opt_.eratio[0]</code>表示<code>stats-eratio1</code>参数，它原本代表L1频点伪距误差相对于载波相位的缩放因子，因为varerr内部的模型是针对载波相位的。这里我拷贝了一份<code>opt_</code>，并以其中的<code>opt_.eratio</code>表示多普勒相对于载波相位的缩放因子，需要注意的是由于不再使用原本的加权方式，这就意味着<code>stats-errdoppler</code>参数将不再生效。</p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171648.jpg" alt=""></p><p>可以看到速度的误差水平有所降低。</p><h2 id="_3-3-m估计-抗差估计" tabindex="-1">3.3 M估计（抗差估计） <a class="header-anchor" href="#_3-3-m估计-抗差估计" aria-label="Permalink to &quot;3.3 M估计（抗差估计）&quot;">​</a></h2><h3 id="_3-3-1-原理与实现" tabindex="-1">3.3.1 原理与实现 <a class="header-anchor" href="#_3-3-1-原理与实现" aria-label="Permalink to &quot;3.3.1 原理与实现&quot;">​</a></h3><p>M估计是一种广义的最大似然估计方法，旨在最小化一个目标函数，该函数对异常值不敏感。其核心思想是通过定义一个损失函数（或称为目标函数）来替代最小二乘法中的平方损失。</p><p>如果换一个角度来看M估计，可以认为它是一种更可靠的加权模型，该加权模型还利用到了验前残差（或新息），验前残差反映了预测与观测之间的差距，差距越小则给观测更大的权重，反之则给观测更小的权重。</p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171756.jpg" alt=""></p><p>M估计的数学表达如上所示。M估计的损失函数（或目标函数）通常包括Huber、IGG3和Tukey模型等，这里我主要关注其中的Huber和IGG3模型。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RobustLsq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">H</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> nx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> nv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>以上为实现M估计的C语言代码，需要注意：</p><ul><li>迭代流程。迭代最小二乘，先计算权，再更新H和v；</li><li>dx初值。初始的时候需要将dx赋值为0，不然结果可能会出现毛刺，本质是增加了迭代次数，以及位置首次迭代会除以残差本身。</li></ul><h3 id="_3-3-2-调参经验" tabindex="-1">3.3.2 调参经验 <a class="header-anchor" href="#_3-3-2-调参经验" aria-label="Permalink to &quot;3.3.2 调参经验&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-171923.jpg" alt=""></p><p>当前使用的Huber模型作为损失函数，位置抗差和速度抗差k的最佳取值是不同的，Huber模型中k默认为1.345，该取值对位置估计有效，但速度估计则需取值为5.0，k的取值更多的还是取决于测试数据所表现的残差水平，一般多试几次即可知道最佳取值。</p><p>当前场景中，IGG3模型没有很好用，尤其是IGG3的第三段，会导致一些残差较大但能正常运算的卫星失去作用，致使参与卫星过少，这主要是因为芯片中伪距中存在频繁的钟跳（参考2.5.2节）。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 位置钟跳的粗略剔除</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AdjustClkJump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nv, H, x, v);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* median inner system as receiver clock */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> …</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 速度钟跳的粗略剔除</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> med </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DemianResOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, nv, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nv; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> med;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> med;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果一定要使用IGG3模型的话，可以在使用前对所有残差数据扣除一个残差中位数（粗略代表钟跳），这样避免IGG3第三段操作时踢掉过多卫星；而Huber模型不需要扣除则是因为Huber不会剔除卫星，而迭代过程中则会消除钟跳误差。Huber等损失函数模型的实现请参考RobustWeightLsq，这里我是按照计算权值的方式对其进行定义的。</p><p>这里的Huber模型和IGG3模型的处理如下：</p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-172043.jpg" alt=""></p><p>可以发现位置估计与速度估计时需要设置不同的参数，而IGG3模型由于面对的是整体残差较大的数据，因此k2需要设置得比一般情况更大的数值。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ROBUST_POS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ROBUST_VEL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0001</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resid;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>损失函数内部需要对残差较大的数据进行截断处理，即返回一个接近0的权值，另外不同算法的残差水平是不同的，需要设置不同的阈值（例如EKF中相应的部分需要设置为30、2）。</p><h3 id="_3-3-3-测试结果" tabindex="-1">3.3.3 测试结果 <a class="header-anchor" href="#_3-3-3-测试结果" aria-label="Permalink to &quot;3.3.3 测试结果&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-172228.jpg" alt=""></p><p>由上表可看到抗差最小二乘比单纯的SNR加权效果要很多。另外Huber的平均水平相较IGG3更好，而IGG3不会像Huber那样容易出现较大的异常偏差。</p><p><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-172325.jpg" alt=""><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-172427.jpg" alt=""><img src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250616-172501.jpg" alt=""></p><p style="text-align:center;">图3-8 SNR加权与Huber抗差对比（02-street/data01）</p><p>以02-street/data01组别数据为例，抗差后的结果所表现的性能提升了很多。</p>`,48)]))}const y=i(n,[["render",t]]);export{g as __pageData,y as default};
