import{_ as t,c as a,a6 as i,o}from"./chunks/framework.B5S16sG3.js";const h=JSON.parse('{"title":"2. 实时定位程序","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/RTKLIB-Source-Notes/02-rtknavi-rtkrcv.md","filePath":"algorithm/RTKLIB-Source-Notes/02-rtknavi-rtkrcv.md"}'),r={name:"algorithm/RTKLIB-Source-Notes/02-rtknavi-rtkrcv.md"};function l(s,e,c,n,d,m){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="_2-实时定位程序" tabindex="-1">2. 实时定位程序 <a class="header-anchor" href="#_2-实时定位程序" aria-label="Permalink to &quot;2. 实时定位程序&quot;">​</a></h1><p>RTKLIB 提供了 GUI 界面程序 RTKNAVI、和 CUI 命令行程序 RTKRCV 以进行实时定位解算。建议在看源码前，先实际动手操作 RTKNAVI，初步理解其中的概念。</p><h2 id="_2-1-rtknavi-使用示例" tabindex="-1">2.1 RTKNAVI 使用示例 <a class="header-anchor" href="#_2-1-rtknavi-使用示例" aria-label="Permalink to &quot;2.1 RTKNAVI 使用示例&quot;">​</a></h2><p>该部分主要参考自资料[25]。</p><h3 id="_2-1-1-软件和数据下载" tabindex="-1">2.1.1 软件和数据下载 <a class="header-anchor" href="#_2-1-1-软件和数据下载" aria-label="Permalink to &quot;2.1.1 软件和数据下载&quot;">​</a></h3><p>RTKLIB 版本为 <a href="https://github.com/rtklibexplorer/RTKLIB/releases" target="_blank" rel="noreferrer">demo5 b34K</a>，另外这里提供一段录制好的 <a href="https://github.com/salmoshu/RTKLIB-Manual-CN/tree/main/sample_data" target="_blank" rel="noreferrer">RTCM 数据</a>。</p><p>通常 RTKNAV 接入的是实时数据流，例如流动站会通过串口连接 GNSS 芯片，而基站通过 TCP 网络连接千寻的 CORS 服务。不过 RTKNAVI 也支持将这些数据录制下来，需要注意的时候，实时数据的录制与回放需要将相应的时间戳记录下来：</p><ul><li>录制对应 RTKNAVI -&gt; [L] -&gt; Time-Tag 复选框；</li><li>回放对应 RTKNAVI -&gt; [I] -&gt; Time 复选框，同时将设置回放速度（如x1）。</li></ul><h3 id="_2-1-2-打开-rtknavi" tabindex="-1">2.1.2 打开 RTKNAVI <a class="header-anchor" href="#_2-1-2-打开-rtknavi" aria-label="Permalink to &quot;2.1.2 打开 RTKNAVI&quot;">​</a></h3><img style="width:80%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-173840.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-1 RTKNAVI 主界面</p><h3 id="_2-1-3-加载配置文件-conf" tabindex="-1">2.1.3 加载配置文件（.conf） <a class="header-anchor" href="#_2-1-3-加载配置文件-conf" aria-label="Permalink to &quot;2.1.3 加载配置文件（.conf）&quot;">​</a></h3><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-180244.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-2 RTKNAVI 配置选项</p><p>通过 [Options] 按钮进入配置选项页面，随后点击其中的 [Load] 按钮，加载配置文件（<code>/sample_data/rtcm/example.conf</code>）。</p><h3 id="_2-1-4-选择输入文件" tabindex="-1">2.1.4 选择输入文件 <a class="header-anchor" href="#_2-1-4-选择输入文件" aria-label="Permalink to &quot;2.1.4 选择输入文件&quot;">​</a></h3><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-180809.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-3 RTKNAVI 输入文件</p><p>点击 RTKNAVI 主页面中的按钮 [I]，随后在输入文件页面中选择输入文件。</p><p>输入流动站和基准站的文件路径。点击“输入文件路径”字段右侧的 [...]，在第一列选择 <code>/sample_data/rtcm/rover.rtcm3</code>。同样在第二列选择 <code>/sample_data/rtcm/base.rtcm3</code>。这段数据是一段绕园区的 1Hz 步行数据，流动站为移远双频模块 LG69T，基站为千寻 CORS。勾选“Time”，并通过右侧下拉菜单选择 x1 来设置回放速度，然后在对话框中点击 [OK]。</p><h3 id="_2-1-5-使用-rtkplot-查看结果" tabindex="-1">2.1.5 使用 RTKPLOT 查看结果 <a class="header-anchor" href="#_2-1-5-使用-rtkplot-查看结果" aria-label="Permalink to &quot;2.1.5 使用 RTKPLOT 查看结果&quot;">​</a></h3><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-182801.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-4 RTKPLOT 窗口</p><p>点击 RTKNAVI 上的 [Plot...] 打开 RTKPLOT 窗口，随后在 [File] 中的 [Open Shapefile...] 中选择一段 GIS Shape 文件 （<code>/sample_data/converted.shp/*</code>），注意这里是导入全部文件。</p><h3 id="_2-1-6-运行-rtknavi" tabindex="-1">2.1.6 运行 RTKNAVI <a class="header-anchor" href="#_2-1-6-运行-rtknavi" aria-label="Permalink to &quot;2.1.6 运行 RTKNAVI&quot;">​</a></h3><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-183624.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-5 RTKNAVI 运行结果</p><p>点击 RTKNAVI 上的 [Start] 按钮。RTKNAVI 开始回放已记录的数据。启动几秒后，您就能得到 RTK 解。解的状态为 FIX 表示已获得模糊度固定的 RTK 解，其精度通常为厘米级。</p><h3 id="_2-1-7-结果对比" tabindex="-1">2.1.7 结果对比 <a class="header-anchor" href="#_2-1-7-结果对比" aria-label="Permalink to &quot;2.1.7 结果对比&quot;">​</a></h3><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-183908.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.1-6 结果对比</p><p>使用 RTKPLOT 左上角的 [连接与断开] 按钮，断开 RTKPLOT 与 RTKNAVI 的连接，随后双击按钮 [2] 并选择参考文件 <code>/sample_data/rtcm/baseline.nmea</code>，该文件是同时录制的和芯星通 UM960 的数据。从结果可以看到即使是优化过的 RTKLIB demo5 性能也与商业模块 UM960 存在有一些差距。</p><p>这主要是因为 RTKLIB 中的抗差和模糊度固定策略还存在改进空间。</p><h2 id="_2-2-数据传递过程" tabindex="-1">2.2 数据传递过程 <a class="header-anchor" href="#_2-2-数据传递过程" aria-label="Permalink to &quot;2.2 数据传递过程&quot;">​</a></h2><h3 id="_2-2-1-概述" tabindex="-1">2.2.1 概述 <a class="header-anchor" href="#_2-2-1-概述" aria-label="Permalink to &quot;2.2.1 概述&quot;">​</a></h3><img style="width:90%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-194544.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-1 RTKNAVI 代码流程</p><p>RTKNAVI 对应的 CUI 程序是 RTKRCV，其主程序为 <code>/RTKLIB-b34L/app/consapp/rtkrcv/rtkrcv.c</code>。</p><p>经过梳理发现 rtkrcv.c 的主函数主要流程如下：</p><ul><li>使用 <code>rtkrcvinit()</code> 函数初始化 <code>svr_t</code> 结构体（<code>svr_t</code> 是一个基本揽括所有的庞大结构体）；</li><li>通过 <code>resetsysopt()</code> 函数重置系统参数，如果有配置文件，会读取配置文件。否则会使用内部默认参数（<code>rtkcmn.c/prcopt_default</code>）；</li><li>通常包含两个线程用以进行实时处理（以串口获取数据为例）： <ul><li><code>serialthread()</code>：通过获取获取 16 进制的 RTCM 数据；</li><li><code>rtksvrthread()</code>：解析来自串口的数据，将其转换为 <code>obs_t</code>, <code>nav_t</code>, <code>rtk_t</code> 等结构体。</li></ul></li><li>核心算法运算 <code>rtkpos()</code>;</li><li>输出结果 <code>writesol()</code>。</li></ul><img style="width:80%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-200703.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-2 RTKNAVI 数据流程</p><p>上图则显示了 RTKNAVI 从 RTCM 的数据、解析再到算法运算的数据流通流程。通常流动站会使用 MSM7 的数据类型，而基站端则使用 MSM4 的数据类型（数据更精简，便于传输）。基站数据中通常不包含星历数据，不过如果需要的话，也可以通过 MSM7 来获取，并在 RTKNAVI 中打开相应的设置（misc-navmsgsel）。</p><h3 id="_2-2-2-rtcm-的读取" tabindex="-1">2.2.2 RTCM 的读取 <a class="header-anchor" href="#_2-2-2-rtcm-的读取" aria-label="Permalink to &quot;2.2.2 RTCM 的读取&quot;">​</a></h3><img style="width:80%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-201545.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-3 RTCM 数据流</p><p>通过观测正在运行的的 RTKNAVI 程序的监视窗口（monitor），可以发现 RTCM 数据基本是以 D3 开头的 16进制数据。</p><img style="width:50%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-201932.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-4 RTCM 数据类别</p><p>具体的 RTCM 报文类别如上所示。</p><h3 id="_2-2-2-rtcm-的解析" tabindex="-1">2.2.2 RTCM 的解析 <a class="header-anchor" href="#_2-2-2-rtcm-的解析" aria-label="Permalink to &quot;2.2.2 RTCM 的解析&quot;">​</a></h3><img style="width:100%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-202409.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-5 RTCM 数据解析</p><ul><li>通过 <code>strread()</code> 函数读取 16 进制的 RTCM 数据，数据存储在 <code>svr-&gt;buff</code> 中；</li><li>在经过 <code>decoderaw()</code> 进行解析时： <ul><li>逐字节读取报文的过程中，每当检测到一个完整的 RTCM 报文就会进行一次报文的拷贝（将 s<code>vr-&gt;buff[]</code> 中单个的 RTCM 报文拷贝到 <code>svr.rtcm-&gt;buff</code> 中；</li><li>会根据报文的类型，完成相应的解析工作（如 <code>decode_msm7()</code>, <code>decode_1019()</code> 等），会根据报文的类型分别存储到 <code>rtcm-&gt;obs</code> 或 <code>rtcm-&gt;nav</code> 结构体中，例如： <ul><li>观测数据：解析 MSM7 数据，会将其存储到 <code>rtcm-&gt;obs</code> 中；</li><li>星历数据：解析 1019 数据，会将其存储到 <code>rtcm-&gt;nav</code> 中；</li><li>定位数据：解析 1006 数据，会将其存储到 <code>rtcm-&gt;sta</code> 中（1006 报文是芯片提供的一个单点定位结果）。</li></ul></li><li>随后利用 <code>updatesvr()</code> 将解析好的 <code>rtcm-&gt;obs</code> 或 <code>rtcm-&gt;nav</code> 数据合入 <code>svr-&gt;obs</code> 或 <code>svr-&gt;nav</code> 结构体中，需要注意的是在解析观测数据（如 MSM7 数据）时，需要检测多个星座是否为同一历元，如果是同一历元，则将其存储在一起（由 RTCM 报文中的同步标识作为判断依据）。</li></ul></li></ul><h3 id="_2-2-3-定位解算" tabindex="-1">2.2.3 定位解算 <a class="header-anchor" href="#_2-2-3-定位解算" aria-label="Permalink to &quot;2.2.3 定位解算&quot;">​</a></h3><img style="width:100%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-210920.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-6 定位前数据准备</p><p>定位之前的星历数据和基站位置数据是通过引用传递进去的，不过观测数据则会进行一次拷贝，具体的是定义一个新的 <code>obs_t</code> 数组，而后将流动站和基站的观测数据顺序存入该数组中。</p><img style="width:60%;margin:10px auto;display:block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250716-211731.jpg"><p style="text-align:center;font-family:&#39;Microsoft YaHei&#39;, SimSun, Arial, sans-serif;font-size:14px;">图2.2-7 定位解算</p><p>最后就是进入定位算法的解算了，更多细节可以参考后续伪距定位、相对定位和精密单点定位的章节。</p><p>对于定位算法以外的部分业务函数，它并非笔者所关注的重点，因此将不会对其进行更多的分析，也不会解析其源码。</p>',62)]))}const u=t(r,[["render",l]]);export{h as __pageData,u as default};
