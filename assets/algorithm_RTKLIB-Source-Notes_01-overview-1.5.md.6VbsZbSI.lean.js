import{_ as d,c as n,a6 as o,j as t,a,G as s,w as e,B as l,o as r}from"./chunks/framework.B5S16sG3.js";const x=JSON.parse('{"title":"1. 初识RTKLIB","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/RTKLIB-Source-Notes/01-overview-1.5.md","filePath":"algorithm/RTKLIB-Source-Notes/01-overview-1.5.md"}'),m={name:"algorithm/RTKLIB-Source-Notes/01-overview-1.5.md"},h={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.714ex",height:"1.935ex",role:"img",focusable:"false",viewBox:"0 -833.2 1199.6 855.2","aria-hidden":"true"};function u(b,i,k,T,E,_){const p=l("mjx-assistive-mml"),g=l("mjx-container"),c=l("GiscusTalk");return r(),n("div",null,[i[6]||(i[6]=o('<h1 id="_1-初识rtklib" tabindex="-1">1. 初识RTKLIB <a class="header-anchor" href="#_1-初识rtklib" aria-label="Permalink to &quot;1. 初识RTKLIB&quot;">​</a></h1><h2 id="_1-5-核心代码库介绍" tabindex="-1">1.5 核心代码库介绍 <a class="header-anchor" href="#_1-5-核心代码库介绍" aria-label="Permalink to &quot;1.5 核心代码库介绍&quot;">​</a></h2><p>代码库（src中包含的程序）是 RTKLIB 的核心，该代码库以方便调用的方式提供给用户，提供了相当全面的GNSS功能服务，也因此RTKLIB中包含了&quot;LIB&quot;的名称。RTKLIB提供的库函数和API（应用程序接口）如下所示：</p><ul><li><strong>基础工具：</strong> 卫星和导航系统函数、矩阵运算函数、时间与字符串函数、坐标转换、平台相关函数、选项配置</li><li><strong>数学模型：</strong> 标准定位、精密定位、整周模糊度固定、星历与时钟函数、大气模型、天线模型、潮汐模型、大地水准面模型、大地基准转换、SBAS</li><li><strong>数据处理：</strong> 输入和输出函数、接收机原始数据处理、解函数（定位结果处理）、KML转换器</li><li><strong>协议支持：</strong> RINEX、RTCM、NMEA</li><li><strong>数据传输：</strong> 数据流服务器、数据下载</li><li><strong>程序调试：</strong> 调试与跟踪</li></ul><p>头文件 rtklib.h 是库的核心 ，主要有四大部分：<strong>宏定义</strong>、<strong>结构体定义</strong>、<strong>全局变量</strong>、<strong>函数定义</strong></p><blockquote><p>注意只有加了 EXPORT 前缀，而且在 rtklib.h 中声明的函数才可以被其他源文件调用。源码中包含了许多以 static 开头的函数，它们在 rtklib.h 没声明，因此无法被外部调用。想调用它们的话，只需要把前缀改成 EXPORT，然后在 rtklib.h 中加上声明，这也是比较常见的需求。</p></blockquote><h3 id="_1-5-1-宏定义" tabindex="-1">1.5.1 宏定义 <a class="header-anchor" href="#_1-5-1-宏定义" aria-label="Permalink to &quot;1.5.1 宏定义&quot;">​</a></h3><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/rtklib.h%20%E5%AE%8F%E5%AE%9A%E4%B9%89.png" alt="rtklib.h 宏定义"></p><p>当前包含的各种 ifdef：</p><ul><li><strong>WIN32、WIN_DLL</strong>：用 Windows 下的代码；</li><li><strong>TRACE</strong>：用于调试信息输出；</li><li><strong>ENAGLO、ENAGAL、ENAQZS、ENACMP、ENAIRN、ENALEO</strong>：启用除 GPS 外的卫星系统，</li><li><strong>OBS_100HZ</strong>：判定时间重合的阈值 DTTOL</li><li><strong>MKL</strong>：使用英特尔数学核心函数库（Intel MKL）</li><li><strong>LAPACK</strong>：使用线性代数包（LAPACK）/基础线性代数子程序（BLAS）</li><li><strong>IERS_MODEL</strong>：使用国际地球自转服务（IERS）潮汐模型</li><li><strong>CPUTIME_IN_GPST</strong>：以全球定位系统时间（GPST）进行CPU时间操作；</li><li><strong>CLOCK_MONOTONIC_RAW</strong>：Linux中用于时间测量的一个时钟源选项；</li><li><strong>RRCENA</strong>：启用循环冗余校验（RRC）校正；</li><li><strong>SVR_REUSEADDR</strong>：重用TCP服务器地址。</li></ul><p>其中 TRACE、ENAGLO、ENAGAL、ENAQZS、ENACMP、ENAIRN、ENALEO 最为常用。</p><hr><h3 id="_1-5-2-结构体定义" tabindex="-1">1.5.2 结构体定义 <a class="header-anchor" href="#_1-5-2-结构体定义" aria-label="Permalink to &quot;1.5.2 结构体定义&quot;">​</a></h3><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/rtklib.h%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="rtklib.h结构体"></p><hr><h3 id="_1-5-3-全局变量" tabindex="-1">1.5.3 全局变量 <a class="header-anchor" href="#_1-5-3-全局变量" aria-label="Permalink to &quot;1.5.3 全局变量&quot;">​</a></h3><ul><li><code>extern const double chisqr[];</code>：<strong>卡方检验表</strong></li><li><code>extern const prcopt_t prcopt_default;</code>：<strong>默认处理选项</strong></li><li><code>extern const solopt_t solopt_default;</code>：<strong>默认结果选项</strong></li><li><code>extern const sbsigpband_t igpband1[9][8];</code>：<strong>SBAS IGP 波段 0-8</strong></li><li><code>extern const sbsigpband_t igpband2[2][5];</code>：<strong>SBAS IGP 波段 9-10</strong></li><li><code>extern const char *formatstrs[];</code>：<strong>数据流格式字符串</strong></li><li><code>extern opt_t sysopts[];</code>：<strong>系统选项表</strong></li></ul><hr><h3 id="_1-5-4-基础函数定义" tabindex="-1">1.5.4 基础函数定义 <a class="header-anchor" href="#_1-5-4-基础函数定义" aria-label="Permalink to &quot;1.5.4 基础函数定义&quot;">​</a></h3><p><strong>1. 矩阵、向量、最小二乘、卡尔曼滤波</strong></p>',20)),t("ul",null,[i[4]||(i[4]=o('<li><p>RTKLIB 中用 double 类型一维数组表示矩阵，不能自动识别矩阵的行列数，每次传矩阵的时候都要传入行数 n、列数 m。</p></li><li><p>用矩阵的时候要先 malloc 开辟空间，用完记得 free 释放空间。</p></li><li><p>要能熟练计算矩阵加减乘除转置求逆。</p></li><li><p>RTKLIB 没有实现矩阵加减的函数，用的时候直接写 for 循环，比如把三维向量 dx 加到 X 上：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) X </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dx;</span></span></code></pre></div></li>',4)),t("li",null,[t("p",null,[i[2]||(i[2]=a("矩阵求逆用的 LU 分解法，时间复杂度 ")),s(g,{class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},{default:e(()=>[(r(),n("svg",h,i[0]||(i[0]=[t("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[t("g",{"data-mml-node":"math"},[t("g",{"data-mml-node":"msup"},[t("g",{"data-mml-node":"mi"},[t("path",{"data-c":"1D442",d:"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z",style:{"stroke-width":"3"}})]),t("g",{"data-mml-node":"mn",transform:"translate(796,363) scale(0.707)"},[t("path",{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z",style:{"stroke-width":"3"}})])])])],-1)]))),s(p,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:e(()=>i[1]||(i[1]=[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("msup",null,[t("mi",null,"O"),t("mn",null,"3")])],-1)])),_:1})]),_:1}),i[3]||(i[3]=a(" ，对于大规模的矩阵，如果利用矩阵的稀疏性和对称性等特性，而且当使用不完全分解方法（例如，只计算到一定程度或使用截断技术）时，LU 分解的效率会更高。"))])]),i[5]||(i[5]=t("li",null,[t("p",null,"matprint() 很常用，调试的时候很难直接看的矩阵元素的值（都是指针），得输出到终端或者文件再看。")],-1))]),i[7]||(i[7]=o('<p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231021091639437.png" alt="image-20231021091639437"></p><hr><p><strong>2. 时间和字符串</strong></p><ul><li>RTKLIB 中时间一般都以 <code>gtime_t</code> 类型存储，为了提高时间表示的精度，分开存 GPST 时间的整秒数和不足一秒的部分。</li><li>经常需要做年月日时分秒、周+周内秒、GPST 三种时间之间的转换；输出北京时间要在 UTC 基础上加 8 小时。</li><li>BDT、GLONASST 不用于计算，读完文件就转为 GPS 时间了。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231021090651319.png" alt="image-20231021090651319"></p><hr><p><strong>3. 坐标转换</strong></p><ul><li>ECI 用的很少，只在 <code>sunmoonpos()</code> 函数中计算日月坐标时候用到了，不用怎么关注。</li><li>ENU、ECEF、LLH 三套坐标系都频繁使用，要熟练掌握他们之间的转换，包括协方差的转换</li><li>ENU 是局部相对坐标系，以某一个 LLH 坐标为原点，坐标转换的时候要传入这个 LLH 坐标。</li><li>ENU 常用 <code>e</code>表示、ECEF 常用 <code>r</code> 表示、LLH 常用 <code>pos</code> 表示。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231021091756265.png" alt="image-20231021091756265"></p><hr><p><strong>4. 卫星系统、观测值</strong></p><ul><li><strong>卫星系统表示</strong>： <ul><li>表示卫星系统的字母：GRECJIS。</li><li>7 位二进制码表示，对应位写 1 表示有对应的系统，做与运算可加系统。</li></ul></li><li><strong>卫星的表示</strong>： <ul><li>可以表示为各系统的卫星 ID（系统缩写+PRN）：B02、C21。</li><li>也可表示为连续的卫星编号 satellite number，断点调试或者看 Trace 文件的时候，经常只能看到卫星编号。</li></ul></li><li><strong>观测值类型</strong>： <ul><li><strong>C</strong>：伪距、<strong>D</strong>：多普勒、<strong>L</strong>：载波相位、<strong>S</strong>：载噪比。</li><li><code>CODE_XXX</code>：观测值类型定义，用一串连续的数字表示。</li><li><code>sigind_t</code>：表示每种卫星系统的载波类型和观测值类型 ，每种类型的系统其实对应的就是一个 <code>sigind_t</code> 结构体。</li></ul></li><li><strong>观测值优先级</strong>：</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231024191221181.png" alt=""></p><hr><h3 id="_1-5-5-选项调试输出" tabindex="-1">1.5.5 选项调试输出 <a class="header-anchor" href="#_1-5-5-选项调试输出" aria-label="Permalink to &quot;1.5.5 选项调试输出&quot;">​</a></h3><p><strong>1. 配置选项读取</strong></p><ul><li>选择主要存在 <code>prcopt_t</code>、<code>solopt_t</code>、<code>filopt_t</code> 三个结构体中。</li><li>后处理解算程序 rnx2rtkp 和实时解算程序 rtksvr 读取结果文件流程是一样的： <ul><li>先调用 <code>resetsysopts()</code> 重置所有配置为默认。</li><li>调用 <code>loadopts()</code> 读取配置文件内容，存入 <code>opt_t</code> 的 <code>sysopt</code> 中。</li><li>最后调用 <code>getsysopts()</code> 将 <code>opt_t</code> 转到 <code>porcopt_t</code>/<code>solopt_t</code>/<code>filopt_t</code>。</li></ul></li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205106288.png" alt="image-20231025205106288"></p><hr><p><strong>2. Trace 调试</strong></p><ul><li>在 rtklib.h 中加入 #define TRACE，启用 trace ，不定义则将 trace 函数全赋空值。</li><li>Trace 信息分五个等级，从 1-5 重要性逐渐降低，通过 tracelevel() 函数可以设置输出的最高等级，设置 2 级意味着只输出 1/2 级信息。 <ul><li><strong>一级 Trace 是致命错误</strong>，出现一级错误基本上意味着程序无法继续执行，比如观测星历文件读取错误、内存分配错误。</li><li><strong>二级 Trace 是警告</strong>，出现二级警告程序可能依然能继续执行，但也可能无法进行解算，比如改正文件读取失败，数据解析出错，二进制数据校验出错，某一历元解算失败，缺失解算所需的星历或改正参数等。</li><li><strong>三级 Trace 是程序主要执行流程</strong>，主要在函数的开头，告诉我们执行到了这个函数。</li><li><strong>四级 Trace 是比三级更深入的程序执行流程</strong>，主要在三级 Trace 函数的中间或者调用的子函数开头，告诉我们执行到了这个操作。</li><li><strong>五级 Trace 是解算的中间过程</strong>，具体到每颗卫星，每个频点，每次循环。</li></ul></li><li>看 Trace 文件可以辅助断点调试，甚至替代断点调试。程序执行出错，开 2/3 级 Trace，看 Trace 文件里的 error、warring 就能知道大致出了啥问题，定位出问题的函数，断点调试的时候你就知道该在哪设置断点了。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205158762.png" alt="image-20231025205158762"></p><hr><p><strong>3. 结果输入输出、NMEA</strong></p><ul><li>输出的结果有两套： <ul><li>定位结果：坐标、协方差、有效果卫星数、差分龄期</li><li>解算中间结果：</li></ul></li><li>NMEA 读取：</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205301277.png" alt="image-20231025205301277"></p><hr><h3 id="_1-5-6-量测数据" tabindex="-1">1.5.6 量测数据 <a class="header-anchor" href="#_1-5-6-量测数据" aria-label="Permalink to &quot;1.5.6 量测数据&quot;">​</a></h3><p><strong>1. 导航数据输入</strong></p><ul><li>用完数据记得释放内存。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205602582.png" alt="image-20231025205602582"></p><hr><p><strong>2. RINEX 文件读写</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205701553.png" alt="image-20231025205701553"></p><hr><p><strong>3. 二进制数据读写</strong></p><ul><li>用于数据流解析。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205800413.png" alt="image-20231025205800413"></p><hr><p><strong>4. 星历数据解析</strong></p><hr><p><strong>5. RTCM 读写</strong></p><p>支持的 RTCM 消息包括：</p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/6a7fd3b4bcb908dfff7b08d7e438bf83.png" alt="6a7fd3b4bcb908dfff7b08d7e438bf83" style="zoom:50%;"><p>想进行定位解释至少要有星历，要有观测数据，常用 NAV 配 MSM4（伪距载波信噪比）、MSM7（伪距载波多普勒信噪比）</p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025205952192.png" alt="image-20231025205952192"></p><hr><p><strong>6. 接收机自定义格式读写</strong></p><p>这里暂未涉及。</p><hr><h3 id="_1-5-7-解算相关" tabindex="-1">1.5.7 解算相关 <a class="header-anchor" href="#_1-5-7-解算相关" aria-label="Permalink to &quot;1.5.7 解算相关&quot;">​</a></h3><p><strong>1. 定位解算入口</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025210531296.png" alt="image-20231025210531296"></p><hr><p><strong>2. 实时解算</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025210624595.png" alt="image-20231025210624595"></p><hr><h3 id="_1-5-8-数据流相关" tabindex="-1">1.5.8 数据流相关 <a class="header-anchor" href="#_1-5-8-数据流相关" aria-label="Permalink to &quot;1.5.8 数据流相关&quot;">​</a></h3><p><strong>1. 数据流</strong></p><ul><li>数据流函数用的大部分在 Window 和 Linux 各有一套，涉及到很多系统库，好在现在 AI 发达，可以用来辅助理解。</li><li>每种数据流关注四个函数：打开、关闭、写数据、读数据。</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025210846191.png" alt="image-20231025210846191"></p><hr><p><strong>2. 数据流线程管理</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025210938225.png" alt="image-20231025210938225"></p><hr><h3 id="_1-5-9-模型改正" tabindex="-1">1.5.9 模型改正 <a class="header-anchor" href="#_1-5-9-模型改正" aria-label="Permalink to &quot;1.5.9 模型改正&quot;">​</a></h3><p><strong>1. 星历、钟差、DCB、FCB</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223050670.png" alt="image-20231025223050670"></p><hr><p><strong>2. SBAS</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223134482.png" alt="image-20231025223134482"></p><hr><p><strong>3. 定位模型：计算高度角、方位角、卫地距、DOP 值</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223220415.png" alt="image-20231025223220415"></p><hr><p><strong>4. 对流层、电离层模型</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223257219.png" alt="image-20231025223257219"></p><hr><p><strong>5. 天线改正：读取天线文件</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223330203.png" alt="image-20231025223330203"></p><hr><p><strong>6. 潮汐改正</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223344099.png" alt="image-20231025223344099"></p><hr><p><strong>7. 水准面模型</strong></p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223357868.png" alt="image-20231025223357868"></p><hr><p><strong>8. 高程转换</strong></p><p>都是转日本的高程系统，咱们用不到。</p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025223409859.png" alt="image-20231025223409859"></p><hr><h3 id="_1-5-10-其它杂项函数" tabindex="-1">1.5.10 其它杂项函数 <a class="header-anchor" href="#_1-5-10-其它杂项函数" aria-label="Permalink to &quot;1.5.10 其它杂项函数&quot;">​</a></h3><p><strong>1. 下载函数</strong></p><hr><p><strong>2. 结果格式转换</strong></p><p>把定位结果转为 KML、GPX 格式：</p><ul><li><strong>KML</strong>：</li><li><strong>GPX</strong>：</li></ul><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025212144253.png" alt="image-20231025212144253"></p><hr><p><strong>3. GIS 数据读取</strong></p><p>可以读取 shapfile 矢量数据</p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025212339125.png" alt="image-20231025212339125"></p><hr><p><strong>4. 平台相关函数</strong></p><p>在 Windows 和 Linux 有完全不同的两套实现</p><p><img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231025212504258.png" alt="image-20231025212504258"></p><hr><p><strong>5. 用户自定义函数</strong></p><p>在 rtklib.h 中声明了，在代码库中使用了，但没有实现，用代码库的时候需要我们自己实现，一般写个空函数就行。编译的时候经常会在这报错，如果说未定义就写三个空实现，如果重定义就把写的实现注释掉。</p><hr><h3 id="_1-5-11-代码库的使用总结" tabindex="-1">1.5.11 代码库的使用总结 <a class="header-anchor" href="#_1-5-11-代码库的使用总结" aria-label="Permalink to &quot;1.5.11 代码库的使用总结&quot;">​</a></h3><p>总结一些命名和函数定义习惯：</p><ul><li>矩阵做参数时一点要带上维度，矩阵 m 为行、n 为列，一般先传 n 后传 m。</li><li>带 <code>const</code> 的指针一定是输入参数，不带 <code>const</code> 的指针是输出参数或者既是输入也是输出。</li><li>类型命名结尾都带 <code>_t</code>，类型传参用的指针名不带 <code>_t</code></li><li>用指针实现了顺序表，</li><li>很多读文件的函数都有结尾带 t 和结尾不带 t 两种，带 t 表示要传入开始时间和结束时间的。</li></ul>',113)),s(c)])}const y=d(m,[["render",u]]);export{x as __pageData,y as default};
